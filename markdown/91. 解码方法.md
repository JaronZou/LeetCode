# 91. 解码方法

一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：

```
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
```

要 **解码** 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，`"11106"` 可以映射为：

- `"AAJF"` ，将消息分组为 `(1 1 10 6)`
- `"KJF"` ，将消息分组为 `(11 10 6)`

注意，消息不能分组为  `(1 11 06)` ，因为 `"06"` 不能映射为 `"F"` ，这是由于 `"6"` 和 `"06"` 在映射中并不等价。

给你一个只含数字的 **非空** 字符串 `s` ，请计算并返回 **解码** 方法的 **总数** 。题目数据保证答案肯定是一个 **32 位** 的整数。

## 解题思路

因为一个字符串的解码方法数与其子串的解码方法数有关，因此我们尝试使用动态规划解决问题。我们定义`dp[i]`的含义为以第 i 项为结尾的字符串的解码方式有`dp[i]`种。

我们按照第 i 次解码使用了多少个字符分类，有以下两种情况。

注：dp表中所有的元素都进行了初始化，值为0。

1. 使用了1个字符(也就是`s[i]`)。因为我们使用了第 i 个字符，因此前面的所有字符我们都认为它们已经进行了解码。解码的方法数保存在`dp[i - 1]`中。此时，有`dp[i] += dp[i - 1]`。

    注意：由于`'0'`没有任何映射，因此当`s[i] == '0'`时，`dp[i] += 0`

2. 使用了2个字符(也就是`s[i]`和`s[i - 1]`)。此时，有`dp[i] += dp[i - 2]`，理由同上。
    
    我们虽然使用了两个数字字符进行解码，但解码可能失败。因为小写字母只有26个，所以两个数字字符必须在`'10' ~ '26'`的范围内才能进行解码。

    注意：`'03'`这样的字符是不能解码的，因为`'03'`与`'3'`在映射中不等价。

整理所有的情况，可以得到：

- `if(s[0] == '0')`
  - `return 0;`
- `if(s[i] != '0')`
  - `dp[i] += dp[i - 1]`
- `if(s[i - 1] == '1' || (s[i - 1] == '2' && s[i] <= '6'))`
  - `dp[i] += dp[i - 2]`


## 算法实现

```cpp
int numDecodings(string s) {
    if(s[0] == '0') {
        return 0;
    }
    if(s.size() == 1) {
        return 1;
    }
    // dp[i]的含义为当前来到s[i]字符有多少种解码方式
    // dp[0] = 1;
    // dp[1] = (s[0] == '1' || (s[0] == '2' && s[1] <= '6')) ? 2 : 1;
    // if(s[i - 1] == '1' || (s[i - 1] == '2' && s[i] <= '6'))
    //      dp[i] = dp[i - 2] 
    // if(s[i] != '0')
    //      dp[i] += dp[i - 1]
    vector<int> dp(s.size(), 0);
    // 初始值
    dp[0] = 1;
    if(s[0] == '1' || (s[0] == '2' && s[1] <= '6')) {
        dp[1] = 1;
    }
    if(s[1] != '0') {
        dp[1] += 1;
    }
    for(int i = 2; i < s.size(); ++i) {
        // 10 ~ 26内的数字都可以一次解码两个数字
        if(s[i - 1] == '1' || (s[i - 1] == '2' && s[i] <= '6')) {
            dp[i] = dp[i - 2];
        }
        // 当前数值不能为0，如果为0，那么只能进行一次解码两个数字
        if(s[i] != '0') {
            dp[i] += dp[i - 1];
        }
    }
    return dp[s.size() - 1];
}
```
